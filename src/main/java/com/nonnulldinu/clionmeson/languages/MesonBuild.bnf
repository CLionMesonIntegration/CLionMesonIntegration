{
  parserClass="com.nonnulldinu.clionmeson.languages.parsers.MesonBuildParser"
  parserUtilClass="com.nonnulldinu.clionmeson.languages.parsers.MesonBuildParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="MesonBuild"
  psiImplClassSuffix="Impl"
  psiPackage="com.nonnulldinu.clionmeson.build.psi"
  psiImplPackage="com.nonnulldinu.clionmeson.build.psi.impl"

  elementTypeHolderClass="com.nonnulldinu.clionmeson.build.psi.MesonBuildTypes"
  elementTypeClass="com.nonnulldinu.clionmeson.build.psi.MesonBuildElement"
  tokenTypeClass="com.nonnulldinu.clionmeson.build.psi.MesonBuildToken"

//  psiImplUtilClass="com.nonnulldinu.clionmeson.build.psi.impl.PsiImplUtil"
  tokens=[
    newline="regexp:\R"
    SPACES="regexp:[ \t]+"

    IN_OP="in"

    BRACE_BEGIN='['
    BRACE_END=']'
    CURLY_BRACE_BEGIN='{'
    CURLY_BRACE_END='}'
    PAREN_BEGIN='('
    PAREN_END=')'
    COMMA=','

    COMP_OP1='=='
    COMP_OP2='<='
    COMP_OP3='>='
    COMP_OP4='<'
    COMP_OP5='>'
    COMP_OP6='!='

    COMP_ATR_OP1='*='
    COMP_ATR_OP2='/='
    COMP_ATR_OP3='%='
    COMP_ATR_OP4='+='
    COMP_ATR_OP5='-='
    ATR_OP='='

    PLUS_OP='+'
    MINUS_OP='-'
    MULT_OP='*'
    DIV_OP='/'
    MOD_OP='%'

    BOOL_LITERAL_TRUE='true'
    BOOL_LITERAL_FALSE='false'

    LANG_TOKEN_FOREACH='foreach'
    LANG_TOKEN_FOREACH_END='endforeach'
    LANG_TOKEN_JUMP_CONTINUE='continue'
    LANG_TOKEN_JUMP_BREAK='break'
    LANG_TOKEN_IF='if'
    LANG_TOKEN_ELSE_IF='elif'
    LANG_TOKEN_ELSE='else'
    LANG_TOKEN_ENDIF='endif'

    LANG_TOKEN_AND='and'
    LANG_TOKEN_OR='or'
    LANG_TOKEN_NOT='not'

    LANG_TOKEN_QMARK='?'
    LANG_TOKEN_COLON=':'

    LANG_TOKEN_DOT='.'

    binnum='regexp:0b[01]+'
    hexnum='regexp:0x[a-fA-F0-9]+'
    octnum='regexp:0[0-7]*' // ok this was supposed to be '0[0-7]+' but we need to match '0' as well so we will do it here
    decnum='regexp:[1-9][0-9]*'
    id='regexp:[a-zA-Z_][a-zA-Z_0-9]*'

//    strmultiline="regexp:'''(.|\n)*?'''"
    strsimple="regexp:'(\\.|[^\\'])*'"

    single_line_comment="regexp://.*"
    multiline_comment="regexp:/\*[.\n]*\*/"
  ]
//  name(".*_expression")='expression'
//  extends(".*_expression")=expression
}

build_definition ::= statement_list
statement_list ::= (statement | newline)*
statement ::= !<<eof>> (func_call_statement | assignment_statement | selection_statement) {pin=2}
//private statement_recover ::= !(newline | func_call_statement | assignment_statement | selection_statement)

// assignment statement
assignment_statement ::= id_expression atrop full_expression newline {pin=2}
atrop ::= "=" | "+=" | "-=" | "/=" | "*=" | "%="

// function call statement
func_call_statement ::= func_name "(" [func_args] ")" newline {pin=2}
func_name ::= id_expression

// if "selection" statement
selection_statement ::= "if" full_bool_expression newline statement_list ("elif" full_bool_expression newline statement_list)* ["else" newline statement_list] "endif" newline {pin=1; recoverWhile=selection_statement_recover}
private selection_statement_recover ::= !"endif" newline

func_args ::= func_arg ("," func_arg)*
func_arg ::= keyword_elem | positional_func_arg
positional_func_arg ::= full_expression
keyword_elem ::= id ":" full_expression

id_expression ::= lvalue

lvalue ::= subscript_expr | id
subscript_root ::= id
subscript_expr ::= subscript_root ("[" full_expression "]")+

array ::= "[" [full_expression ("," full_expression)*] "]"
dict ::= "{" [keyword_elem ("," keyword_elem)*] "}"

// mult
mul_op ::= "*" | "/" | "%"
mul_expr ::= factor (mul_op factor)*
factor ::= dict | array | par_expression | id_expression | string_literal | num_literal

// add
add_op ::= "+" | "-"
add_expr ::= mul_expr (add_op mul_expr)*

// relation check
equality_op ::= "==" | "!="
rel_check_op ::= "<" | ">" | "<=" | ">=" | equality_op
rel_check_expr ::= expression rel_check_op expression {pin=2}

// and, or and not
simple_bool_expression ::= rel_check_expr | expression | "not" simple_bool_expression

conditional_and_expression ::= simple_bool_expression ("and" simple_bool_expression)*

conditional_or_expression ::= conditional_and_expression ("or" conditional_and_expression)*

full_bool_expression ::= conditional_or_expression

expression ::= dict | array | add_expr | id_expression | string_literal | num_literal | par_expression
par_expression ::= "(" full_expression ")"

full_expression ::= full_bool_expression | expression

// literals
private string_literal ::= /*strmultiline |*/ strsimple

private num_literal ::= bin_literal | oct_literal | dec_literal | hex_literal
private bin_literal ::= binnum
private oct_literal ::= octnum
private dec_literal ::= decnum
private hex_literal ::= hexnum

fake comment ::= single_line_comment | multiline_comment