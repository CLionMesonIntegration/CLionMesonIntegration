{
  parserClass="com.nonnulldinu.clionmeson.languages.parsers.MesonBuildParser"
  parserUtilClass="com.nonnulldinu.clionmeson.languages.parsers.MesonBuildParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="MesonBuild"
  psiImplClassSuffix="Impl"
  psiPackage="com.nonnulldinu.clionmeson.build.psi"
  psiImplPackage="com.nonnulldinu.clionmeson.build.psi.impl"

  elementTypeHolderClass="com.nonnulldinu.clionmeson.build.psi.MesonBuildTypes"
  elementTypeClass="com.nonnulldinu.clionmeson.build.elements.MesonBuildElement"
  tokenTypeClass="com.nonnulldinu.clionmeson.build.elements.MesonBuildToken"

//  psiImplUtilClass="com.nonnulldinu.clionmeson.build.psi.impl.PsiImplUtil"
  tokens=[
    newline="regexp:\s*\R\s*"
    SPACES="regexp:[ \t]+"

    IN_OP="in"

    BRACE_BEGIN='['
    BRACE_END=']'
    CURLY_BRACE_BEGIN='{'
    CURLY_BRACE_END='}'
    PAREN_BEGIN='('
    PAREN_END=')'
    COMMA=','

    COMP_OP1='=='
    COMP_OP2='<='
    COMP_OP3='>='
    COMP_OP4='<'
    COMP_OP5='>'
    COMP_OP6='!='

    COMP_ATR_OP1='*='
    COMP_ATR_OP2='/='
    COMP_ATR_OP3='%='
    COMP_ATR_OP4='+='
    COMP_ATR_OP5='-='
    ATR_OP='='

    PLUS_OP='+'
    MINUS_OP='-'
    MULT_OP='*'
    DIV_OP='/'
    MOD_OP='%'

    BOOL_LITERAL_TRUE='true'
    BOOL_LITERAL_FALSE='false'

    LANG_TOKEN_FOREACH='foreach'
    LANG_TOKEN_FOREACH_END='endforeach'
    LANG_TOKEN_JUMP_CONTINUE='continue'
    LANG_TOKEN_JUMP_BREAK='break'
    LANG_TOKEN_IF='if'
    LANG_TOKEN_ELSE_IF='elif'
    LANG_TOKEN_ELSE='else'
    LANG_TOKEN_ENDIF='endif'

    LANG_TOKEN_AND='and'
    LANG_TOKEN_OR='or'
    LANG_TOKEN_NOT='not'

    LANG_TOKEN_QMARK='?'
    LANG_TOKEN_COLON=':'

    LANG_TOKEN_DOT='.'

    binnum='regexp:0b[01]+'
    hexnum='regexp:0x[a-fA-F0-9]+'
    octnum='regexp:0[0-7]*' // ok this was supposed to be '0[0-7]+' but we need to match '0' as well so we will do it here
    decnum='regexp:[1-9][0-9]*'
    id='regexp:[a-zA-Z_][a-zA-Z_0-9]*'

    strmultiline="regexp:'''(.|\n)*'''"
    strsimple="regexp:'(\\.|[^\\'])*'"

    block_comment="regexp:(\h*?#.*?\R+)(\h*?#.*?\R+)+"
    line_comment="regexp:#.*\R+"
  ]
//  name(".*_expression")='expression'
//  extends(".*_expression")=expression
}

build_definition ::= statement_list
statement_list ::= (statement | newline)*
for_statement_list ::= (for_statement | newline)*
statement ::= !<<eof>> (method_call_statement | func_call_statement | assignment_statement | selection_statement | repetitive_statement) {pin=2; recoverWhile=statement_recover}
private statement_recover ::= newline
for_statement ::= !<<eof>> (method_call_statement | func_call_statement | assignment_statement | selection_statement | repetitive_statement | control_statement) {pin=2; recoverWhile=statement_recover}
control_statement ::= ("continue" | "break") newline

// assignment statement
assignment_statement ::= id_expression atrop full_expression newline {pin=2}
atrop ::= "=" | "+=" | "-=" | "/=" | "*=" | "%="

// function call statement
func_call_expression ::= func_name "(" [func_args] ")" {pin=2}
func_call_statement ::= func_call_expression newline
func_name ::= id

// if "selection" statement
selection_statement ::= "if" full_bool_expression newline statement_list ("elif" full_bool_expression newline statement_list)* ["else" newline statement_list] "endif" newline {pin=1; recoverWhile=selection_statement_recover}
private selection_statement_recover ::= !"endif" newline

repetitive_statement ::= "foreach" id_list ":" expression newline for_statement_list "endforeach" newline {pin=1; recoverWhile=repetitive_statement_recover}
private repetitive_statement_recover ::= !"endforeach" newline

func_args ::= newline? func_arg (newline? "," newline? func_arg)*(","? newline?)
func_arg ::= keyword_elem | positional_func_arg
positional_func_arg ::= full_expression
keyword_elem ::= id ":" full_expression

id_expression ::= lvalue
id_list ::= id ("," id)*

method_call_expression_base ::= dict | array | func_call_expression | par_expression | id | string_literal | num_literal
method_call_chain ::= method_call_expression_base ("." func_call_expression | index_expr)+
method_call_statement ::= method_call_chain newline

lvalue ::= subscript_expr | id
subscript_root ::= method_call_chain | id
index_expr ::= "[" full_expression "]"
subscript_expr ::= subscript_root index_expr+

array ::= "[" [newline? full_expression (newline? "," newline? full_expression)*] (","? newline?) "]"
dict ::= "{" [newline? keyword_elem (newline? "," newline? keyword_elem)*] (","? newline?) "}"

// mult
mul_op ::= "*" | "/" | "%"
mul_expr ::= factor (mul_op factor)*
factor ::= dict | array | method_call_chain | func_call_expression | par_expression | id_expression | string_literal | num_literal

// add
add_op ::= "+" | "-"
add_expr ::= mul_expr (add_op mul_expr)*

// relation check
equality_op ::= "==" | "!="
rel_check_op ::= "<" | ">" | "<=" | ">=" | equality_op
rel_check_expr ::= expression rel_check_op expression {pin=2}

// boolean logic
bool_literal ::= "true" | "false"

unary_num_op ::= "+" | "-"

// and, or and not
simple_bool_expression ::= rel_check_expr | method_call_chain | func_call_expression | expression | par_expression | id | bool_literal | "not" simple_bool_expression

conditional_and_expression ::= simple_bool_expression ("and" simple_bool_expression)*

conditional_or_expression ::= conditional_and_expression ("or" conditional_and_expression)*

full_bool_expression ::= conditional_or_expression

expression ::= dict | array | add_expr | string_literal | num_literal_unary | num_literal | par_expression
par_expression ::= "(" full_expression ")"

ternary_expression ::= full_bool_expression "?" full_expression ":" full_expression

full_expression ::= ternary_expression | full_bool_expression | expression

// literals
private string_literal ::= strmultiline | strsimple

num_literal_unary ::= unary_num_op num_literal
private num_literal ::= bin_literal | oct_literal | dec_literal | hex_literal
private bin_literal ::= binnum
private oct_literal ::= octnum
private dec_literal ::= decnum
private hex_literal ::= hexnum